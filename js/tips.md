<!--
 * @Author: your name
 * @Date: 2020-10-22 08:48:27
 * @LastEditTime: 2020-10-28 17:42:12
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: \basicTips\js\tips.md
-->

## 1. 回调函数和任务队列的区别

  #### 回调函数是作为参数传给另一个函数的参数，这个函数会在另一个函数执行完成后执行。
  #### 任务队列是一个事件的队列，IO设备完成一项任务后，就在队列中添加一个事件，表示相关的异步任务可以进入执行栈。

  #### 同步任务：主线程上排队执行的任务，前一个任务执行完成后才能执行下一个任务。
  #### 异步任务：不进入主线程，进入任务队列的任务。只有当主线程上的同步任务执行完成后，主线程才会读取任务队列中的任务，等待主线程读取。

  #### 任务队列中的事件包括IO设备的事件，用户产生的事件。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。
  #### 异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

## 2.微任务和宏任务的区别

  #### 微任务和宏任务是异步任务的两个队列
  #### 宏任务：当前调用栈中执行的任务，例如 主代码块，定时器等等
  #### 微任务：当前（此次事件循环中）宏任务执行，在下一个宏任务开始之前需要执行的任务，可以理解未回调事件。例如：promise.then,proness.nextTick等等

  #### 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务中的事件放在微任务队列中，由js引擎线程维护。



## 3.BFC

  #### BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。Box是CSS布局的对象和基本单位。

    >> 块级格式化上下文布局规则
      * 内部的BOX会在垂直方向一个接一个的放置
      * 属于同一个BFC的两个相邻的BOX的margin会重叠
      * 是页面上一个隔离的独立容器，里面的元素不会影响到外面的元素
      * BFC的区域不会和float box重叠
      * 计算BFC的高度，浮动元素也参与计算
  >> 触发条件
  >>> 触发条件简要概括
    * 根元素
    * 浮动元素
    * position为absolute或fixed
    * overflow不为visible
    * display为inline-block,table-cell,table-caption,flex,inline-flex
  >>>触发条件详细介绍
    * 根元素/浮动元素/绝对定位元素/行内快元素/表格单元格/表格标题/匿名表格单元格元素/overflow值不为visible的块元素
    * 弹性元素/网格元素/多列容器/display为flow-root/contain值为layout.content.paint/column-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中
  >> 应用场景
    * 清除内部浮动，触发父元素的BFC属性，会包含float元素
    * 分属于不同的BFC，可以阻止Margin重叠
    * 阻止元素被浮动元素覆盖，各自是独立的渲染区域
    * 自适应两栏布局


## 4.BOM（浏览器对象模型）

  ### location对象获取页面信息，navigator对象了解浏览器,history对象操作浏览器历史，BOM的核心是window对象，但实际上是用Js开发web应用程序的核心，控制窗口及弹窗。

  > window
    * window是es中的global对象，也是浏览器窗口的JavaScript的接口。





  ... moveTo是接收要移动到的新位置的绝对坐标；moveBy只接收相对当前位置在两个方向上移动的像素数。




## 5.对象  P468
  > 数据属性包括（Configurable,Enumberable,Writable,Value）
    >> Configurable 表示属性是否可以通过delete删除并重新定义
  > 访问器属性（Configurable,Enumberable,Get,Set),必须使用Object.defineProperty()
    >> 用途: 设置一个属性值会导致一些其他变化发生
        **** es5之前会使用用两个非标准的访问 创建访问器属性： __defineGetter__() 和 __defineSetter__()
  * Object.defineProperties()方法可以通过多个描述符一次性定义多个属性
  > Object.assign
    >> 将每个源对象中可枚举和自有属性复制到目标对象。 修改目标对象，也会返回修改后的目标对象
    >> 对每个源对象执行的是浅复制。不能在两个对象间转移获取函数和设置函数
  *** Object.is()，这个方法用来判断对象是否相等，比 === 更周全，例如Object.is(NaN,NaN) 返回为true  NaN===NaN 返回为false

  > 继承 通过原型继承多个引用类型的属性和方法
    >> 每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。
    >> 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。
    >> 寄生式继承，先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。可以避免重复调用父类构造函数导致的浪费。
    >> 原型链继承是所有的属性和方法都会在对象实例间共享，无法做到实例私有。
    >>  盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）
    >> 组合继承 ，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性

  *** 盗用构造函数：在子类构造函数中调用父类构造函数。使用Object.create会遮蔽原型对象上的同名属性。

  ##
   * DOM事件流分为3个阶段：事件捕获，到达目标，事件冒泡。

